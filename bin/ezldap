#!/usr/bin/env python3

import os
import sys
import argparse
import getpass
import pkg_resources

import yaml
import ezldap

def main():
    parser = argparse.ArgumentParser(
        description='ezldap CLI - Perform various options on an LDAP directory.',
        # not sure why the formatter width can't be resized...
        formatter_class=lambda prog: argparse.HelpFormatter(prog, indent_increment=1))
    parser.add_argument('-v', '--version', action='version', version=
        '%(prog)s version {}'.format(ezldap.__version__))
    subparsers = parser.add_subparsers(title='Valid commands', metavar='')

    def help_msg(_):
        parser.print_help()
        print()

    parser.set_defaults(func=help_msg)

    # subparsers follow
    config_parser = subparsers.add_parser('config',
        help='Configure ezldap (configs are stored in ~/.ezldap/).',
        description='Create a set of configs for ezldap scripts under ~/.ezldap/. '
        'To delete your ezldap config, just delete the ~/.ezldap folder.')
    config_parser.add_argument('-f', '--force', default=False, const=True, action='store_const',
        help='Whether to force overwriting existing config files in ~/.ezldap '
        '(namely LDIF templates).')
    config_parser.set_defaults(func=config)

    search_parser = subparsers.add_parser('search',
        help='Search for entities by LDAP filter.',
        description='Search for objects in a directory using LDAP filters. '
        'Example: "(objectClass=*)".')
    search_parser.add_argument('filter', nargs=1, type=str, default='(objectClass=*)',
        help='LDAP filter to search by, for example: (objectClass=*)')
    search_parser.set_defaults(func=search)

    search_dn_parser = subparsers.add_parser('search_dn',
        help='Search for and print DNs in a directory that match a keyword.',
        description='Search LDAP tree for a DN keyword and a list of matching DNs.')
    search_dn_parser.add_argument('keyword', nargs='?', type=str, default='',
        help='Keyword to search DNs by (case-sensitive).')
    search_dn_parser.set_defaults(func=search_dn)

    add_user_parser = subparsers.add_parser('add_user', help='Add a user.',
        description="Creates an LDAP user and add to a group. "
        "Creates a same-named LDAP group as well if no group specified. "
        "Prints the randomly generated password to stdout.")
    add_user_parser.add_argument('username', nargs=1, type=str,
        help="Username to create.")
    add_user_parser.add_argument('groupname', nargs='?', type=str, default=None,
        help="Groupname to add user to. If omitted, creates same-named LDAP group. "
        "If the group is a local group, a new LDAP group will not be created "
        "and an ldap add group operation will not be perfomed.")
    add_user_parser.add_argument('--ldif-user', nargs=1, type=str,
        default=['~/.ezldap/add_user.ldif'],
        help='Path of LDIF template to use when adding a user.')
    add_user_parser.add_argument('--ldif-group', nargs=1, type=str,
        default=['~/.ezldap/add_group.ldif'],
        help='Path of LDIF template to use when adding a group.')
    add_user_parser.add_argument('--ldif-add-to-group', nargs=1, type=str,
        default=['~/.ezldap/add_to_group.ldif'],
        help='Path of LDIF template to use when adding a group.')
    add_user_parser.set_defaults(func=add_user)

    add_group_parser = subparsers.add_parser('add_group', help='Add a group.',
        description="Creates an LDAP group using a presupplied LDIF template.")
    add_group_parser.add_argument('groupname', nargs=1, type=str,
        help='LDAP group name to create.')
    add_group_parser.add_argument('gid', nargs='?', type=str, default=None,
        help='GID number of group to create. '
        'If not supplied, uses next available GID number.')
    add_group_parser.add_argument('--ldif', nargs=1, type=str,
        default=['~/.ezldap/add_group.ldif'],
        help='Path of LDIF template to use when performing this operation.')
    add_group_parser.set_defaults(func=add_group)

    add_to_group_parser = subparsers.add_parser('add_to_group',
        help='Add a user to a group.',
        description='Add a user to an LDAP group using a presupplied LDIF template.')
    add_to_group_parser.add_argument('username', nargs=1, type=str,
        help='An LDAP username to add to a group.')
    add_to_group_parser.add_argument('groupname', nargs=1, type=str,
        help='An LDAP groupname to add to a group.')
    add_to_group_parser.add_argument('--ldif', nargs=1, type=str,
        default=['~/.ezldap/add_to_group.ldif'],
        help='Path of LDIF template to use when performing this operation.')
    add_to_group_parser.set_defaults(func=add_to_group)

    modify_desc = 'Add, replace, or delete an attribute from an entity.'
    modify_parser = subparsers.add_parser('modify',
        help=modify_desc, description=modify_desc)
    modify_parser.add_argument('dn', nargs=1, type=str,
        help='Distinguished Name (DN) of object to modify.')
    modify_parser.add_argument('operation', nargs=1, type=str,
        choices=['add', 'replace', 'delete'],
        help='Type of operation to perform. Can be one of: add, replace, delete.')
    modify_parser.add_argument('value', nargs=1, type=str,
        help='Value to add, replace, or delete. '
        'When performing a delete operation, passing "-" will delete all values for that attribute.')
    modify_parser.add_argument('replace_with', nargs='?', type=str,
        help='Value to replace an attribute with when performing a replace operation.')
    modify_parser.set_defaults(func=modify)


    delete_desc = 'Delete an entry from an LDAP directory.'
    delete_parser = subparsers.add_parser('delete', help=delete_desc,
        description=delete_desc+' Will print the entry and prompt for confirmation.')
    delete_parser.add_argument('-f', '--force', default=False, const=True, action='store_const',
        help='Do not print entry and do not prompt for confirmation.')
    delete_parser.add_argument('dn', nargs=1, type=str,
        help='Distinguished Name (DN) of object to delete.')
    delete_parser.set_defaults(func=delete)

    ch_home_desc="Change a user's home directory."
    change_home_parser = subparsers.add_parser('change_home',
        help=ch_home_desc, description=ch_home_desc)
    change_home_parser.add_argument('username', nargs=1, type=str,
        help='User to change homeDirectory for.')
    change_home_parser.add_argument('homedir', nargs=1, type=str,
        help='New home directory.')
    change_home_parser.set_defaults(func=change_home)

    ch_shell_desc = "Change a user's default shell."
    change_shell_parser = subparsers.add_parser('change_shell',
        help=ch_shell_desc, description=ch_shell_desc)
    change_shell_parser.add_argument('username', nargs=1, type=str,
        help='User to change loginShell for.')
    change_shell_parser.add_argument('shell', nargs=1, type=str,
        help='Desired shell for user.')
    change_shell_parser.set_defaults(func=change_shell)

    ch_pw_desc="Change or reset a user's password."
    change_pw_parser = subparsers.add_parser('change_pw',
        help=ch_pw_desc, description=ch_pw_desc)
    change_pw_parser.add_argument('username', nargs=1, type=str,
        help='User to reset password for.')
    change_pw_parser.add_argument('-s', '--specify-password',
        default=False, const=True, action='store_const',
        help='Specify a password instead of randomizing it.')
    change_pw_parser.set_defaults(func=change_pw)

    check_pw_parser = subparsers.add_parser('check_pw',
        help="Check a user's password.",
        description='Verify that an LDAP password is correct. '
        'Currently only works with SSHA-encrypted passwords.')
    check_pw_parser.add_argument('username', nargs='?', type=str,
        help='If a username is supplied, this will check that user\'s password. '
        'You will otherwise be prompted for the password hash.')
    check_pw_parser.set_defaults(func=check_pw)

    server_info_desc = 'Print information about the LDAP server you are using.',
    server_info_parser = subparsers.add_parser('server_info',
        help=server_info_desc, description=server_info_desc)
    server_info_parser.set_defaults(func=server_info)

    class_info_desc = 'Print information about a specific LDAP objectClass.',
    class_info_parser = subparsers.add_parser('class_info',
        help=class_info_desc, description=class_info_desc)
    class_info_parser.add_argument('objectClass', nargs=1, type=str,
        help='objectClass to investigate.')
    class_info_parser.set_defaults(func=class_info)

    argv = parser.parse_args()
    argv.func(argv)


def add_group(argv):
    gid = argv.gid
    with ezldap.auto_bind() as con:
        if gid is None:
            gid = con.next_gidn()

        con.add_group(argv.groupname[0], gid=gid, ldif_path=argv.ldif[0])


def add_to_group(argv):
    with ezldap.auto_bind() as con:
        con.add_to_group(argv.username[0], argv.groupname[0], ldif_path=argv.ldif[0])


def add_user(argv):
    user = argv.username[0]
    group = argv.groupname

    with ezldap.auto_bind() as con:
        if group is None:
            # No group specified, perform a second check for groups named after
            # the user, then create it.
            group = user
            if con.get_group(group) is None:
                print('Creating LDAP group {}...'.format(group))
                con.add_group(group, ldif_path=argv.ldif_group[0])
        elif con.get_group(group) is None:
            sys.exit('Group does not exist.')

        passwd = ezldap.random_passwd()
        print('Creating user {}, member of LDAP group {}...'.format(user, group))
        con.add_user(user, group, passwd, ldif_path=argv.ldif_user[0])
        con.add_to_group(user, group, ldif_path=argv.ldif_add_to_group[0])
        print('Password: {}'.format(user, passwd))


def modify(argv):
    pass


def delete(argv):
    dn = argv.dn[0]
    with ezldap.auto_bind() as con:
        if not argv.force:
            #TODO add recursive delete
            query = con.search_list(search_base=dn, search_scope=ldap3.BASE)
            ldif_print(query)

            confirm = input('Delete object? (y/N) ')
            if confirm[0] != 'y':
                sys.exit('Operation aborted.')

        con.delete(dn)


def change_home(argv):
    with ezldap.auto_bind() as con:
        dn = con.get_user(argv.username[0])['dn'][0]
        con.modify_replace(dn, 'homeDirectory', argv.homedir[0])


def change_shell(argv):
    with ezldap.auto_bind() as con:
        dn = con.get_user(argv.username[0])['dn'][0]
        con.modify_replace(dn, 'loginShell', argv.shell[0])


def change_pw(argv):
    user = argv.username[0]
    if argv.specify_password:
        print('Specify new password for {}...'.format(user))
        passwd = getpass.getpass()
    else:
        passwd = ezldap.random_passwd()
        print('New password for {} - {}'.format(user, passwd))

    ssha = ezldap.ssha_passwd(passwd)

    with ezldap.auto_bind() as con:
        try:
            dn = con.get_user(user)['dn'][0]
        except IndexError:
            sys.exit('User does not exist.')

        con.modify_replace(dn, 'userPassword', ssha)


def check_pw(argv):
    if argv.username is None:
        print('Enter SSHA password hash...')
        ssha = getpass.getpass()
    else:
        with ezldap.auto_bind() as con:
            query = con.get_user(argv.username)
            if len(query) != 1:
                sys.exit('User not found.')

            ssha = ezldap.get_attrib_list(query, 'userPassword')[0]

    print('\nEnter password to verify...')
    passwd = getpass.getpass()

    if ezldap.ssha_check(ssha, passwd):
        print('\nPasswords match!')
    else:
        print("\nPasswords do not match. :'(")


def config(argv):
    if os.path.exists(os.path.expanduser('~/.ezldap/config.yml')):
        conf = ezldap.config()
    else:
        conf = ezldap.guess_config()

    prompts = {
        'host': 'LDAP host',
        'binddn': 'Bind DN (leave blank for anonymous bind)',
        'bindpw': 'Bind password (leave blank to prompt for password)',
        'peopledn': 'User base dn',
        'groupdn': 'Group base dn',
        'homedir': 'Default home directory for new users'
    }

    for k, v in prompts.items():
        conf[k] = interactive_conf(v, conf[k])

    os.makedirs(os.path.expanduser('~/.ezldap'), mode=0o700, exist_ok=True)
    yaml.dump(conf,
        stream=open(os.path.expanduser('~/.ezldap/config.yml'), 'w'),
        default_flow_style=False)

    for template in pkg_resources.resource_listdir('ezldap', 'templates'):
        if argv.force or not os.path.exists(os.path.expanduser('~/.ezldap/' + template)):
            content = pkg_resources.resource_string('ezldap', 'templates/' + template).decode()
            with open(os.path.expanduser('~/.ezldap/' + template), 'w') as fout:
                fout.write(content)


def interactive_conf(prompt, default=None):
    '''
    Prompt the user for a config value, press ENTER for default val.
    '''
    if default is None:
        val = input('{}: '.format(prompt))
    else:
        val = input('{} [{}]: '.format(prompt, default))

    if val == '':
        return default
    else:
        return val


def search(argv):
    conf = ezldap.config()
    with ezldap.Connection(conf['host']) as con:
        ezldap.ldif_print(con.search_list(search_filter=argv.filter[0]))


def search_dn(argv):
    conf = ezldap.config()
    with ezldap.Connection(conf['host']) as con:
        # You cannot use dn as a search filter, so we dump all dns and then
        # search through those ourselves.
        query = con.search_list_t(attributes=None)

    for dn in query['dn']:
        if argv.keyword in dn:
            print(dn)


def server_info(argv):
    conf = ezldap.config()
    with ezldap.Connection(conf['host']) as con:
        print(con.server.info, end='')


def class_info(argv):
    conf = ezldap.config()
    with ezldap.Connection(conf['host']) as con:
        try:
            print(con.server.schema.object_classes[argv.objectClass[0]])
        except KeyError:
            print('objectClass "{}" not found.'.format(argv.objectClass[0]))


if __name__ == '__main__':
    main()
